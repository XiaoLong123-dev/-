[TOC]



## 后台管理项目

* vue3的深度监听，在ref定义的复杂数据类型时需要自己添加，而reactive会自动开启
* `undefined`
* - 这个变量从根本上就没有定义
  - 隐藏式 空值
  - Boolean(undefined)=false
  - `undefined` 转换为 `number` 时，会转换为 `NaN`
* `null`
* - 这个值虽然定义了，但它并未指向任何内存中的对象
  - 声明式 空值
  - Boolean(null)=false
  - `null` 转化为 `number` 时，会转换成 `0`

* css“+”和"~"选择器
  * **‘+’选择器则表示某元素后相邻的兄弟元素，也就是紧挨着的，是单个的。而‘~’选择器则表示某元素后所有同级的指定元素，强调所有的**

### 事件的三个阶段

> 一个事件的处理过程主要有三个阶段：捕获、目标、冒泡。

* 捕获阶段：当我们在 DOM 树的某个节点发生了一些操作（例如单击、鼠标移动上去），就会有一个事件发射过去。这个事件从 Window 发出，不断经过下级节点直到触发的目标节点。在到达目标节点之前的过程，就是捕获阶段（Capture Phase）。（所有经过的节点，都会触发这个事件。捕获阶段的任务就是建立这个事件传递路线，以便后面冒泡阶段顺着这条路线返回 Window。）
* 目标阶段：当事件不断的传递直到目标节点的时候，最终在目标节点上触发这个事件，就是目标阶段。
* 冒泡阶段：事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后逐级传播到较为不具体的节点（我们平时用的事件绑定就是利用的事件冒泡的原理）

> - 事件捕获: 事件捕获指的是从document到触发事件的那个节点，即自上而下的去触发事件。
> - 事件冒泡：事件冒泡刚好相反，是从触发事件的那个节点一直到document，是自下而上的去触发事件。
> - 事件委托：利用了事件冒泡的原理，在下方通过实例讲解
> - 阻止事件委托和冒泡：在事件函数中执行event.stopPropagation()
> - 事件默认都是在冒泡阶段出发，可以使用``document.getElementById("child").addEventListener("click",function(e){
>               console.log("child事件被触发，"+this.id);
>           },true);``
> - 改为在捕获阶段触发

### vue.config.js

```js
const { defineConfig } = require("@vue/cli-service");
const path = require("path");

module.exports = defineConfig({
  transpileDependencies: true,
    // 关闭eslint语法检查
  lintOnSave: false,

  devServer: {
    // 代理跨域的配置
    proxy: {
      // 当我们的本地的请求 有/api的时候，就会代理我们的请求地址向另外一个服务器发出请求
      "/api": {
        target: "http://ihrm-java.itheima.net/", // 跨域请求的地址
        changeOrigin: true, // 只有这个值为true的情况下 才表示开启跨域
      },
    },
  },
  //路径别名的配置
  configureWebpack: {
    resolve: {
      alias: {
        "@": path.join(__dirname, "src"),
      },
    },
  },
});

```

### 请求的封装

* utils

  * ```js
    import axios from "axios";
    import { Message } from "element-ui";
    // 设置当前最新的时间戳
    import { getTimeStamp } from "@/utils/auth";
    import store from "@/store";
    import router from "@/router";
    const TimeOut = 5400; // 定义超时时间
    const service = axios.create({
      //    设置基础地址
      // 环境变量 npm run dev  /api   /生产环境 npm run build  /prod-api
      baseURL: process.env.VUE_APP_BASE_API,
      timeout: 10000, // 认为只要超过5秒钟不响应 就超时
    });
    
    
    // 请求拦截器
    service.interceptors.request.use(
      (config) => {
        // config请求配置
        // 检查是否携带token
        if (store.getters.token) {
          // 如果有token,则把token注入到请求头中
          config.headers["Authorization"] = `Bearer ${store.getters.token}`;
        }
        // 一定要返回config
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
    
    
    // 响应拦截器
    service.interceptors.response.use(
      (response) => {
        // axios 默认包裹了一层data
        const { success, data, message } = response.data;
        // 执行成功
        if (success) {
          return { success, data, message };
        } else {
          // 执行失败
          Message.error(message);
          return Promise.reject(new Error(message));
        }
      },
      (err) => {
        Message.error(err.message);
        return Promise.reject(err);
      }
    );
    
    export default service;
    ```
    
  * utils/auth.js
  
  * ```js
    import Cookies from 'js-cookie'
    
    const TokenKey = 'hr-saas-111-token'
    
    const timeKey = 'hr-sass-time-key' // 用来作为时间戳存储的key
    
    export function getToken() {
      return Cookies.get(TokenKey)
    }
    
    export function setToken(token) {
      return Cookies.set(TokenKey, token)
    }
    
    export function removeToken() {
      return Cookies.remove(TokenKey)
    }
    
    export function setTimeStamp() {
      // 设置当前最新的时间戳
      // Date.now()  new Date.getTime()
      Cookies.set(timeKey, Date.now())
    }
    
    export function getTimeStamp() {
      return Cookies.get(timeKey)
    }
    
    ```
  
  * 

### 路由管理

* ``router/index.js``

  * > 路由分为静态路由和动态路由
    >
    > 静态路由：一直显示的路由
    >
    > 动态路由：根据权限信息决定是否要显示的路由

  * ```js
    import Vue from "vue";
    import VueRouter from "vue-router";
    Vue.use(VueRouter);
    
    const Login = () => import("@/pages/login");
    const Layout = () => import("@/layout/Layout");
    
    // 二级路由
    const Home = () => import("@/pages/home");
    
    export const constRoutes = [
      {
        path: "/login",
        component: Login,
        // 不在菜单中显示
        hidden: true,
      },
    
      {
        path: "/404",
        component: () => import("@/pages/404.vue"),
        // 不在菜单中显示
        hidden: true,
      },
      // 匹配不到的时候
      {
        path: "*",
        redirect: "/404",
        hidden: true,
      },
    
      {
        path: "/",
        component: Layout,
        redirect: "/home",
        meta: { title: "选项一", icon: "el-icon-s-platform" },
        children: [
          {
            path: "home",
            component: Home,
            meta: { title: "主页一", icon: "el-icon-s-platform" },
          },
        ],
      },
    ];
    
    const createRouter = () =>
      new VueRouter({
        mode: "history",
        scrollBehavior: () => ({ y: 0 }),
        routes: constRoutes,
      });
    
    const router = createRouter();
    
    // export function resetRouter() {
    //   const newRouter = createRouter();
    //   router.matcher = newRouter.matcher;
    // }
    
    export default router;
    
    ```

* 一级路由出口

  * ```vue
    // app.vue
    <template>
      <div id="app">
          // 一级路由出口
        <router-view></router-view>
      </div>
    </template>
    
    <script>
    export default {
      name: "App",
      components: {},
    };
    </script>
    
    <style>
    </style>
    
    ```

### 主页结构

#### Layout页面

* ``layout.vue``

> layout是主要页面，其中SideBar是左侧导航栏组件，根据路由信息遍历生成；TagsView是右侧头部组件，包括面包屑、头像等

* ```vue
  <template>
    <div class="home">
      <el-row type="flex">
        <!-- 左侧导航栏 -->
        <el-col :span="part">
          <div class="left">
            <!-- logo -->
            <img src="~@/assets/common/logo.png" alt="" srcset="" />
  
            <!-- 左侧导航栏 -->
            <el-menu
              router
              unique-opened
              :collapse-transition="false"
              class="el-menu-vertical-demo"
              background-color="#46A3FF"
              text-color="#fff"
              active-text-color="#ffd04b"
              :collapse="isCollapse"
            >
              <SideBar :tree="routes"></SideBar>
            </el-menu>
          </div>
        </el-col>
        <!-- 导航栏结束 -->
  
        <!-- 右侧头部 -->
        <!-- 不写:span="20"会自动计算剩余部分 -->
        <el-col>
          <div class="right">
            <!-- 控制导航栏的显示或隐藏 -->
            <div class="hideOrDisplay" @click="hideOrDisplay">
              <transition-group name="myIcon">
                <i
                  class="el-icon-s-fold"
                  v-if="!isCollapse"
                  key="el-icon-s-fold"
                ></i>
                <i class="el-icon-s-unfold" key="el-icon-s-unfold" v-else></i>
              </transition-group>
            </div>
  
            <!-- 头部面包屑部分 -->
            <TagsView></TagsView>
          </div>
  
          <!-- 内容区域 -->
          <div class="content">
            <router-view></router-view>
          </div> </el-col
      ></el-row>
    </div>
  </template>
  
  
  <script>
  import SideBar from "@/layout/components/SideBar/SideBar.vue";
  import TagsView from "@/layout/components/TagsView";
  export default {
    name: "Layout",
    components: { SideBar, TagsView },
    data() {
      return {
        // 导航栏是否折叠
        isCollapse: false,
        // 导航栏在layout布局中占几份
        part: 4,
  
        // 所有路由表
        routes: [],
      };
    },
  
    created() {
      this.getRoutes();
    },
    mounted() {},
  
    methods: {
      hideOrDisplay() {
        if (this.isCollapse) {
          this.isCollapse = false;
          this.part = 4;
        } else {
          this.isCollapse = true;
          this.part = 1;
        }
      },
      getRoutes() {
        // 获取所有路由表,用于遍历路由生成导航菜单
        this.routes = this.$router.options.routes;
        // console.log(this.$router.options.routes);
      },
    },
  
    mounted() {
    },
  
  };
  </script>
  
  <style lang="less" >
  .home {
    // 超出部分滚动，但是去除滚动条
    // overflow-x: hidden;
    // overflow-y: scroll;
    .left {
      height: 100vh;
      background-color: #46a3ff;
      overflow: hidden;
  
    }
    .right {
      position: relative;
      overflow: hidden;
      width: 100%;
      height: 8vh;
      border-bottom: 1px solid #e0e0e0;
      background-color: #46a3ff;
      .hideOrDisplay {
        position: absolute;
        left: 10px;
        top: 17px;
        font-size: 26px;
      }
    }
    .content {
      width: 100%;
      height: 92vh;
      padding-left: 10px;
      overflow: hidden;
      padding: 10px;
    }
  }
  </style>
  ```
  
* ``sidebar.vue``
  
  * > 根据组件递归生成导航菜单
  
  * ```vue
    <template>
      <div>
        <div v-for="(item, index) in tree" :key="index">
          <!-- hidden=true且该路由又有子路由时 直接递归进入子路由 -->
          <div v-if="item.hidden && item.children">
            <SideBar :tree="item.children"></SideBar>
          </div>
          <div v-if="!item.hidden">
            <el-submenu :index="item.path" v-if="item.children">
              <template slot="title">
                <i :class="item.meta.icon || ''"></i>
                <span>{{ item.meta.title }}</span>
              </template>
              <SideBar :tree="item.children"></SideBar>
            </el-submenu>
    
            <el-menu-item :index="item.path" v-if="!item.children">
              <i :class="item.meta.icon || ''"></i>
              <span slot="title">
                {{ item.meta.title }}
              </span>
            </el-menu-item>
          </div>
        </div>
      </div>
    </template>
    
    <script>
    export default {
      name: "SideBar",
      props: {
          // 接受所有的路由信息
        tree: {
          type: Array,
          default: () => [],
        },
      },
    
      mounted() {
        // console.log(this.tree);
      },
    };
    </script>
    
    <style lang="less" scoped>
    /deep/ .el-icon-arrow-down:before {
      color: white;
    }
    .el-menu-vertical-demo {
      height: 100%;
    }
    img {
      width: 100%;
    }
    </style>
    ```
  
* ``tagsview.vue``

  * 面包屑暂时有问题??????

  * ```vue
    <template>
      <div>
        <!-- 面包屑 -->
        <el-breadcrumb separator-class="el-icon-arrow-right" class="right-top">
          <!-- <el-breadcrumb-item :to="{ path: '/home' }"
                  >首页</el-breadcrumb-item
                > -->
          <el-breadcrumb-item
            :to="item.path"
            v-for="(item, index) in matcheds"
            :key="index"
            >{{ item.name }}</el-breadcrumb-item
          >
        </el-breadcrumb>
    
        <!-- 头像信息 -->
        <div class="demo-type">
          <div>
            <el-avatar v-imageerror="defaultImage" :src="staffPhoto"></el-avatar>
            <!-- <el-avatar 
                    src="https://cube.elemecdn.com/0/88/03b0d39583f48206768a7534e55bcpng.png"
                  ></el-avatar> -->
          </div>
          <!-- 姓名 -->
          <div class="demo-type-name">Hi~ {{ name }}</div>
        </div>
        +
    
        <!-- 下拉菜单 -->
        <el-dropdown class="downselect" trigger="click" @command="handleCommand">
          <span class="el-dropdown-link">
            <i class="el-icon-arrow-down el-icon--right"></i>
          </span>
          <el-dropdown-menu slot="dropdown">
            <el-dropdown-item command="login"> 登录</el-dropdown-item>
            <el-dropdown-item command="giteeaddress">
              <a href="https://gitee.com/" target="_black">项目地址</a>
            </el-dropdown-item>
            <el-dropdown-item command="loginout">退出账号</el-dropdown-item>
          </el-dropdown-menu>
        </el-dropdown>
      </div>
    </template>
    
    <script>
    import { mapActions, mapGetters } from "vuex";
    export default {
      name: "TagsView",
      data() {
        return {
          // 路由信息
          matcheds: [],
          // 默认头像
          defaultImage: require("@/assets/common/head.jpg"),
        };
      },
      computed: {
        ...mapGetters(["name", "staffPhoto"]),
        // 对图片进行处理
      },
    
      methods: {
        ...mapActions(["user/getUserInfo", "user/loinout"]),
        // 打开导航栏
        // handleOpen(key, keyPath) {
        // console.log(this.$route);
        // console.log(key, keyPath);
        // },
        // 关闭导航栏
        // handleClose(key, keyPath) {
        //   console.log(key, keyPath);
        // },
    
        // 点击下拉菜单的事件
        handleCommand(command) {
          // 点击登录
          if (command == "login") {
            this.$router.push("/login");
          }
          // 点击退出登录
          if (command == "loginout") {
            // 删除token和用户信息
            this["user/loinout"]();
            // 跳转到登录
            this.$router.push("/login");
          }
        },
      },
      mounted() {},
      // 检测路由的变化，同步面包屑
      watch: {
        $route: {
          handler() {
            if (this.$route.matched.length > 0) {
              // this.matcheds = this.$route.matched.filter(
              //   (item) => item.name && item.name != "首页"
              // );
              this.matcheds = this.$route.matched;
              // console.log(this.$route.matched);
            }
          },
          immediate: true,
          deep: true,
        },
      },
    };
    </script>
    <style lang="less" >
    .right-top {
      line-height: 8vh;
      text-align: center;
      padding-left: 50px;
    }
    .demo-type {
      display: flex;
      position: absolute;
      right: 40px;
      top: 10px;
      cursor: pointer;
      vertical-align: middle;
      .demo-type-name {
        margin-top: 12px;
        padding: 0 10px;
      }
    }
    .downselect {
      position: absolute;
      top: 20px;
      right: 20px;
    
      .el-dropdown-link {
        cursor: pointer;
        // color: #409eff;
        color: white;
      }
      .el-icon-arrow-down {
        font-size: 12px;
      }
    }
    </style>
    ```

  * 

* 如何处理点击导航栏之后路由的跳转

  > 根据element-ui中的导航栏组件中的el-menu的属性，分别是
  >
  > router：是否使用 vue-router 的模式，启用该模式会在激活导航时以 index 作为 path 进行路由跳转
  >
  >  :*default-active*="$route.fullPath"	根据当前路由地址激活
  >
  > 之后再<el-menu-item *index*="/home/home1"> 选项1 </el-menu-item>中，index属性是需要跳转的路由地址

  * ```vue
     <el-menu
     router
     :default-active="$route.fullPath"
     class="el-menu-vertical-demo"
     @open="handleOpen"
     background-color="#545c64"
     text-color="#fff"
     active-text-color="#ffd04b"
    >
         
    <el-submenu index="1">
        
      <template slot="title">
        <i class="el-icon-location"></i>
        <span>导航一</span>
      </template>
        
      <el-menu-item-group>
        <el-menu-item index="/home/home1"> 选项1 </el-menu-item>
        <el-menu-item index="1-2">选项2</el-menu-item>
      </el-menu-item-group>
        
      <el-submenu index="1-4">
        <template slot="title">选项3</template>
        <el-menu-item index="1-4-1">选项1</el-menu-item>
      </el-submenu>
        
    </el-submenu>
    
    </el-menu>
    ```

* 如何面包屑组件和导航栏组件的联动

  > 利用监听器watch，监听路由$route的变化,定义一个数组存储路由中的this.$route.matched属性，其中存储了所有的路由信息，在页面中进行遍历

  * ```vue
    <!-- 面包屑 -->
              <el-breadcrumb
                separator-class="el-icon-arrow-right"
                class="right-top"
                v-if="matcheds.length > 0"
              >
                <el-breadcrumb-item
                  :to="item.path"
                  v-for="(item, index) in matcheds"
                  :key="index"
                  >{{ item.name }}</el-breadcrumb-item
                >
              </el-breadcrumb>
    <!-- 面包屑 -->
      watch: {
        $route: {
          handler() {
            this.matcheds = this.$route.matched;
            console.log(this.$route.matched);
          },
          immediate: true,
          deep: true,
        },
      },
    ```

#### 主页的权限管理

  * ![](D:\pink\后台管理系统\mycode\myproject\image-20200716004526838.png)

  * ```js
    // 路由权限管理
    
    import router from "@/router/index";
    import store from "@/store/index";
    // 进度条
    import nprogress from "nprogress";
    import "nprogress/nprogress.css";
    
    // 定义路由的白名单
    const whiteList = ["/login", "/404"];
    
    // 前置守卫
    router.beforeEach((to, form, next) => {
      // 开启进度条
      nprogress.start();
    
      // 获取token
      const token = store.getters.token;
      //   判断token是否存在
      if (token) {
        // 如果token存在
        // 判断是否去登录页
        if (to.path == "/login") {
          // 已经有token了，直接跳转到主页
          next({ path: "/" });
        } else {
          next();
        }
      } else {
        // 如果token不存在
        // 是否去不需要权限的页面，如404
        if (whiteList.indexOf(to.path) > -1) {
          // 要去的地址在白名单
          next();
        } else {
          next("/login");
        }
      }
      // 关闭进度条--为了解决手动切换地址时进度条不关闭的问题
      nprogress.done();
    });
    
    // 后置守卫
    router.afterEach(() => {
      // 关闭进度条
      nprogress.done();
    });
    
    ```



#### 登录模块的实现

* 布局及其element-ui表单校验

  * ```vue
    <template>
      <div class="box">
        <div class="login">
          <el-form
            :model="ruleForm"
            status-icon
            :rules="rules"
            ref="ruleForm"
            label-width="50px"
            class="demo-ruleForm"
          >
            <el-form-item label="账号" prop="mobile">
              <el-input v-model="ruleForm.mobile"></el-input>
            </el-form-item>
    
            <el-form-item label="密码" prop="password" class="pass">
              <el-input
                :type="typeName"
                v-model="ruleForm.password"
                autocomplete="off"
              ></el-input>
              <i class="el-icon-view" @click="showpass"></i>
            </el-form-item>
    
            <el-form-item>
              <el-button type="primary" @click="submitForm('ruleForm')">
                <i class="el-icon-loading" v-show="isLoading"></i> 提交</el-button
              >
              <el-button @click="resetForm('ruleForm')">重置</el-button>
              <el-button @click="registerForm">注册</el-button>
            </el-form-item>
          </el-form>
        </div>
      </div>
    </template>
    
    <script>
    import { login } from "@/api/user/";
    import { mapActions } from "vuex";
    export default {
      name: "Login",
      data() {
        // 表单验证规则
        // 账号验证
        var checkmobile = (rule, value, callback) => {
          if (!value) {
            return callback(new Error("账号不能为空"));
          }
          if (value.length != 11) {
            return callback(new Error("手机号必须11位"));
          }
          callback();
        };
        // 密码验证
        var validatepassword = (rule, value, callback) => {
          if (value === "") {
            callback(new Error("请输入密码"));
          } else {
            if (value.length < 6 || value.length > 16) {
              callback(new Error("最少6位,最多16位"));
            } else {
              callback();
            }
          }
        };
        return {
          // 表单收集的数据
          ruleForm: {
            password: "123456",
            mobile: "13800000002",
          },
          rules: {
            password: [{ validator: validatepassword, trigger: "blur" }],
            mobile: [{ validator: checkmobile, trigger: "blur" }],
          },
          // 密码的显示
          typeName: "password",
          // 提交加载中
          isLoading: false,
        };
      },
      methods: {
        // 引入vuex方法
        ...mapActions(["user/getToken"]),
        // 提交按钮
        submitForm(formName) {
          // 对整个表单进行校验
          // validate 参数为一个回调函数。该回调函数会在校验结束后被调用，
          // 并传入两个参数：是否校验成功(valid)和未通过校验的字段(object)。若不传入回调函数，则会返回一个 promise
          this.$refs[formName].validate(async (valid, object) => {
            // console.log(valid);
            // console.log(object);
            if (valid) {
              try {
                this.isLoading = true;
                // 强制等待请求成功之后在执行其他代码
                await this["user/getToken"](this.ruleForm);
                // 跳转到home主页
                this.$router.push("/");
              } catch (error) {
                console.log(error);
              } finally {
                this.isLoading = false;
              }
            } else {
              console.log("error submit!!");
              return false;
            }
          });
        },
        // 重置按钮
        resetForm(formName) {
          this.$refs[formName].resetFields();
        },
        // 跳转到注册
        registerForm() {
          console.log("register");
        },
        // 密码显示
        showpass() {
          if (this.typeName == "password") {
            this.typeName = "text";
          } else {
            this.typeName = "password";
          }
        },
      },
    };
    </script>
    
    <style lang="less" scoped>
    .box {
      width: 100%;
      height: 100%;
      /* 
      background：color img_url repeat attachment position / size
      attachment  是否固定或者跟随页面滚动。
      */
      background: url("../../images/bg.jpg") no-repeat center / cover;
    
      .login {
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        margin: auto;
        width: 500px;
        height: 230px;
        border: 1px solid white;
        border-radius: 20px;
    
        display: flex;
        justify-content: center;
        align-items: center;
    
        .pass {
          position: relative;
          i {
            position: absolute;
            top: 15px;
            right: 30px;
          }
        }
      }
    }
    </style>
    ```

* 登录模块相关的api

  * ```js
    // 与用户相关的接口
    import request from "@/utils/request";
    
    // 登陆的接口
    export const login = (data) => {
      return request({
        url: "/sys/login",
        method: "post",
        data,
      });
    };
    
    ```

* user仓库

  * ```js
    import { getToken, setToken, removeToken, setTimeStamp } from "@/utils/auth";
    import { login } from "@/api/user";
    const state = {
      token: getToken(),
      userInfo: {},
    };
    
    const actions = {
      // 获取登陆数据
      async getToken(context, data) {
        let result = await login(data); // 获取token
        if (result.success) {
          context.commit("GETTOKEN", result.data);
        }
      },
    };
    
    const mutations = {
      // 设置token
      GETTOKEN(state, data) {
        state.token = data;
        // 设置缓存
        setToken(data.token);
      },
    };
    
    export default {
      namespaced: true,
      state,
      actions,
      mutations,
    };
    
    ```

* 获取用户的信息

  * api/user.js

  * ```js
    // 获取用户信息
    export const getUserInfoList = () => {
      return request({
        url: "/sys/profile",
        method: "post",
      });
    };
    ```

  * store/user.js

  * ```js
    
    const state = {
      userInfo: {},
    };
    
    const actions = {
      // 获取用户信息
      async getUserInfo(context, data) {
        let result = await getUserInfoList();
        // console.log(result);
        if (result.success) {
          context.commit("GETUSERINFO", result.data);
        }
      },
    };
    
    const mutations = {
      //获取用户信息
      GETUSERINFO(state, data) {
        state.userInfo = data;
      },
    };
    
    export default {
      namespaced: true,
      state,
      actions,
      mutations,
    };
    
    ```

  * 在请求拦截器判断存在token时，触发请求获取信息

  * ```vue
    
    // 前置守卫
    router.beforeEach(async (to, form, next) => {
      // 开启进度条
      nprogress.start();
    
      // 获取token
      const token = store.getters.token;
    
      //   判断token是否存在
      // 只有在token存在的时候才获取用户信息
      if (token) {
        // 如果token存在
        // 判断是否去登录页
        if (to.path == "/login") {
          // 已经有token了，直接跳转到主页
          next({ path: "/" });
        } else {
    
    +      // 获取用户信息
    +      // 只有在放行的时候才去获取用户资料
    +      // 判断vuex中是否已经存储了用户的信息
    +      if (!store.getters.userId) {
    +        await store.dispatch("user/getUserInfo");
    +        // 如果后续需要根据用户的资料获取数据 这里必须是同步
    +      }
    
          next();
        }
      } else {
        // 如果token不存在
        // 是否去不需要权限的页面，如404
        if (whiteList.indexOf(to.path) > -1) {
          // 要去的地址在白名单
          next();
        } else {
          next("/login");
        }
      }
      // 关闭进度条--为了解决手动切换地址时进度条不关闭的问题
      nprogress.done();
    });
    ```

* 获取头像接口，合并数据

  * api/user

  * ```js
    // 通过id获取用户的基本信息
    export const getUserDetailById = (id) => {
      return request({
        url: `/sys/user/${id}`,
      });
    };
    ```

  * store/modules/user

  * ```js
    const actions = {
      // 获取用户信息
      async getUserInfo(context, data) {
        let result = await getUserInfoList();
        // 根据id获取用户的详情
        let obj = await getUserDetailById(result.data.userId);
    
        if (result.success) {
          context.commit("GETUSERINFO", { ...result.data, ...obj.data });
        }
        return result.data; // 权限管理的时候会用到
      },
    };
    ```

  * store/getters

  * ```js
    const getters = {
      token: (state) => state.user.token,
      name: (state) => state.user.userInfo.username, //名称
      userId: (state) => state.user.userInfo.userId, //id
      staffPhoto: (state) => state.user.userInfo.staffPhoto, // 头像
    };
    export default getters;
    
    ```



#### 实现用户的登出

* page/home

  * ```js
        // 点击下拉菜单的事件
        handleCommand(command) {
          // 点击登录
          if (command == "login") {
            this.$router.push("/login");
          }
          // 点击项目地址
    
          // 点击退出登录
          if (command == "loginout") {
            // 删除token和用户信息
            this["user/loinout"]();
            // 跳转到登录
            this.$router.push("/login");
          }
        },
    ```

* store/moudles/user

  * ```js
    import { getToken, setToken, removeToken, setTimeStamp } from "@/utils/auth";
    const actions = {
      // 登出操作
      loinout(context) {
        // 清除token
        context.commit("RETOKEN");
        // 清除 用户资料
        context.commit("REUSERINFO");
      },
    };
    
    const mutations = {
      // 移除token
      RETOKEN(state) {
        state.token = null;
        // 清除缓存
        removeToken();
      },
      // 删除用户信息
      REUSERINFO(state) {
        state.userInfo = {};
      },
    };
    ```

#### 处理token失效问题

> 在获取token的时候设置当前的时间戳，在使用token的时候判断时间戳是否失效

* utils/request

  ```js
  import axios from "axios";
  import { Message } from "element-ui";
  // 设置当前最新的时间戳
  import { getTimeStamp } from "@/utils/auth";
  import store from "@/store";
  import router from "@/router";
  const TimeOut = 3600; // 定义超时时间
  const service = axios.create({
    //    设置基础地址
    // 环境变量 npm run dev  /api   /生产环境 npm run build  /prod-api
    baseURL: process.env.VUE_APP_BASE_API,
    timeout: 5000, // 认为只要超过5秒钟不响应 就超时
  });
  
  // 请求拦截器
  service.interceptors.request.use(
    (config) => {
      // config请求配置
      // 检查是否携带token
      if (store.getters.token) {
        // 在token存在的情况下，在判断token是否会超时
        if (isCheckTimeout()) {
          // 已经超时了
          // 清空token
          store.dispatch("user/loinout");
          router.push("/login");
  
          return Promise.reject(new Error("token超时了"));
        }
        // 如果有token,则把token注入到请求头中
        config.headers["Authorization"] = `Bearer ${store.getters.token}`;
      }
      // 一定要返回config
      return config;
    },
    (error) => {
      return Promise.reject(error);
    }
  );
  
  // 响应拦截器
  service.interceptors.response.use(
    (response) => {
      // axios 默认包裹了一层data
      const { success, data, message } = response.data;
      // 执行成功
      if (success) {
        return { success, data, message };
      } else {
        // 执行失败
        Message.error(message);
        return Promise.reject(new Error(message));
      }
    },
    (err) => {
      Message.error(err.message);
      return Promise.reject(err);
    }
  );
  
  // 定义检查时间戳是否超时
  function isCheckTimeout() {
    // 获取当前时间戳
    let currentTime = Data.now();
    // 获取缓存的时间戳
    let timeStamp = getTimeStamp();
  
    return (currentTime - timeStamp) / 1000 > TimeOut;
  }
  
  export default service;
  
  ```
### 自定义指令的全局注册

  > 为了解决获取到的图片链接失效的问题

* 自定义指令的用法

  * ```js
    // 全局指令
    Vue.directive('指令名称',{
        钩子函数:function(el,bind,vnode,oldVnode){
            // 处理逻辑
        }
    })
    ```

  * ```js
    // 局部的
    directives: {
      指令名称: {
        // 指令的定义
        钩子函数: function (el,bind,vnode,oldVnode) {
         	// 处理逻辑
        }
      }
    }
    ```

* 钩子函数

  * `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
  * `inserted`：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
  * `update`：所在组件的 VNode 更新时调用，**但是可能发生在其子 VNode 更新之前**。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
  * `componentUpdated`：指令所在组件的 VNode **及其子 VNode** 全部更新后调用。
  * `unbind`：只调用一次，指令与元素解绑时调用。

* 钩子函数参数

  * `el`：指令所绑定的元素，可以用来直接操作 DOM。
  * ``binding``：一个对象，包含以下 property：
    - `name`：指令名，不包括 `v-` 前缀。
    - `value`：指令的绑定值，例如：`v-my-directive="1 + 1"` 中，绑定值为 `2`。
    - `oldValue`：指令绑定的前一个值，仅在 `update` 和 `componentUpdated` 钩子中可用。无论值是否改变都可用。
    - `expression`：字符串形式的指令表达式。例如 `v-my-directive="1 + 1"` 中，表达式为 `"1 + 1"`。
    - `arg`：传给指令的参数，可选。例如 `v-my-directive:foo` 中，参数为 `"foo"`。
    - `modifiers`：一个包含修饰符的对象。例如：`v-my-directive.foo.bar` 中，修饰符对象为 `{ foo: true, bar: true }`。
  * `vnode`：Vue 编译生成的虚拟节点。移步 [VNode API](https://v2.cn.vuejs.org/v2/api/#VNode-接口) 来了解更多详情。
  * `oldVnode`：上一个虚拟节点，仅在 `update` 和 `componentUpdated` 钩子中可用。

* 案例：

  * ```vue
    <div id="hook-arguments-example" v-demo:foo.a.b="message"></div>
    Vue.directive('demo', {
      bind: function (el, binding, vnode) {
        var s = JSON.stringify
        el.innerHTML =
          'name: '       + s(binding.name) + '<br>' +
          'value: '      + s(binding.value) + '<br>' +
          'expression: ' + s(binding.expression) + '<br>' +
          'argument: '   + s(binding.arg) + '<br>' +
          'modifiers: '  + s(binding.modifiers) + '<br>' +
      }
    })
    
    new Vue({
      el: '#hook-arguments-example',
      data: {
        message: 'hello!'
      }
    })
    name:"demo"
    value:"hello"
    expression:"message"
    argment:"foo"
    modifiers:"{a:true,b:true}"
    
    ```

    

  * 新的导出语法``import * as xx from 'xx'``
    * 获取所有暴露的值并组合成一个对象并起名为xx
    
    * ```vue
      // 注册自定义指令
      Object.keys(directive).forEach((item) => {
        // console.log(item, directive[item]);
        //  Vue.directive('自定义指令名', directive[item]);
        Vue.directive(item, directive[item]);
      });
      ```
    
  * src/directives

    * ```js
      // 自定义指令
      export const imageerror = {
        // 指令对象,会在当前的dom元素插入到结点之后执行
        inserted(dom, options) {
          // options是 指令中的变量的解释  其中有一个属性叫value
          // dom 表示当前指令作用的dom对象
          // dom 认为此时就是图片
          // 当图片有地址 但是地址没有加载成功的时候会报错 会触发图片的一个事件=>error
          dom.onerror = function () {
            // 当图片出现异常的时候 会降指令配置的默认图片设置为该图片的内容
            // dom 可以注册error事件
            dom.src = options.value;
          };
        },
      };
      
      ```

### 新建页面结构和路由模块

* src/pages

  * ```
    ├── departments         # 组织架构
    ├── employees           # 员工
    ├── setting             # 公司设置
    ├── salarys             # 工资
    ├── social              # 社保
    ├── attendances         # 考勤
    ├── approvals           # 审批
    ├── permission          # 权限管理
    ```

* 快速新建文件夹

  * ```bash
    $ mkdir departments employees setting salarys social attendances approvals permission
    ```

#### 设置每个的路由规则文件

```
  ├── router               # 路由目录
   ├── index.js            # 路由主文件
   ├── modules             # 模块目录
    ├── departments.js     # 组织架构
    ├── employees.js       # 员工 
    ├── setting.js         # 公司设置
    ├── salarys.js         # 工资
    ├── social.js          # 社保
    ├── attendances.js     # 考勤
    ├── approvals.js       # 审批
    ├── permission.js      # 权限管理
```

 * 这些文件都是动态路由，不能和静态路由放在一起，也就是不能放在router/index.js中
* 路由规则需要再次引入Layout重新写

##### 员工的路由规则

* 正常写法

  * ```js
    // 导出属于员工的路由规则
    import Layout from '@/layout'
    //  {  path: '', component: '' }
    // 每个子模块 其实 都是外层是layout  组件位于layout的二级路由里面
    export default {
    +  path: '/employees', // 路径
      name: 'employees', // 给路由规则加一个name
      component: Layout, // 组件
      // 配置二级路的路由表
      children: [{
    +    path: '', // 这里当二级路由的path什么都不写的时候 表示该路由为当前二级路由的默认路由
        component: () => import('@/views/employees'),
        // 路由元信息  其实就是存储数据的对象 我们可以在这里放置一些信息
        meta: {
          title: '员工管理' // meta属性的里面的属性 随意定义 但是这里为什么要用title呢， 因为左侧导航会读取我们的路由里的meta里面的title作为显示菜单名称
        }
      }]
    }
    
    // 当你的访问地址 是 /employees的时候 layout组件会显示 此时 你的二级路由的默认组件  也会显示
    
    ```

* 我的写法

  * ```js
    // 引入layout(因为需要他的布局)
    // 每个子模块 其实 都是外层是layout  组件位于layout的二级路由里面
    import Layout from "@/layout/Layout.vue";
    
    // 暴露员工管理的路由规则(单个路由规则以对象的形式暴露)
    export default {
    +  path: "/employees",
      component: Layout,
      meta: { title: "员工管理", icon: "el-icon-s-platform" },
      // 配置二级路的路由表
      children: [
        {
    +      path: "/employees", // 这里当二级路由的path什么都不写的时候 表示该路由为当前二级路由的默认路由
          component: () => import("@/pages/employees"),
          name: "employees", // 给路由规则加一个name，权限管理需要用
    
          // 路由元信息  其实就是存储数据的对象 我们可以在这里放置一些信息
          meta: {
            title: "员工管理", // meta属性的里面的属性 随意定义 但是这里为什么要用title呢， 因为左侧导航会读取我们的路由里的meta里面的title作为显示菜单名称
            icon: "el-icon-s-platform",
          },
        },
      ],
    };
    // 当你的访问地址 是 /employees的时候 layout组件会显示 此时 你的二级路由的默认组件  也会显示
    
    ```

  * 其他类似

### 其他页面的搭建

#### 组织架构的搭建

> 也就是公司的结构

* 将树级内容封装成treeTools组件

  * ```vue
    <template>
      <el-row
        type="flex"
        justify="space-between"
        align="middle"
        style="height: 40px; width: 100%"
      >
        <el-col>
          <!-- 左侧结构  -->
          <i :class="treeNode.icon" style="padding-right: 5px"></i>
          <span>{{ treeNode.label }}</span>
        </el-col>
    
        <el-col :span="5">
          <!-- 右侧结构 -->
          <el-row type="flex" justify="end">
            <el-col>{{ treeNode.manger }}</el-col>
            <el-col>
              <!-- 下拉菜单 -->
              <el-dropdown trigger="hover">
                <span class="el-dropdown-link">
                  操作<i class="el-icon-arrow-down el-icon--right"></i>
                </span>
                <!-- slot="dropdown" -->
                <el-dropdown-menu slot="dropdown">
                  <slot name="dropdown"></slot>
                  <!-- <el-dropdown-item icon="el-icon-plus"
                    >添加子部门</el-dropdown-item
                  >
                  <el-dropdown-item icon="el-icon-plus"
                    >编辑子部门</el-dropdown-item
                  >
                  <el-dropdown-item icon="el-icon-plus"
                    >删除子部门</el-dropdown-item
                  > -->
                </el-dropdown-menu>
              </el-dropdown>
            </el-col>
          </el-row>
        </el-col>
      </el-row>
    </template>
    
    <script>
    export default {
      name: "treeTools",
      props: {
        treeNode: {
          type: Object,
          required: true,
        },
      },
    };
    </script>
    
    <style>
    </style>
    ```

* 主页 index.vue

  * ```vue
    <template>
      <div class="dashboard-container">
        <div class="app-container">
          <!-- 组织架构-内容 -->
          <el-card class="departments-head">
            <!-- 放置结构内容 -->
            <treeTools :treeNode="company" @showAddDep="showAddDep"> </treeTools>
          </el-card>
          <!-- 树形组件结构 -->
          <!--node-key	每个树节点用来作为唯一标识的属性，整棵树应该是唯一的 
                default-expand-all	是否默认展开所有节点
                allow-drag	判断节点能否被拖拽 
                   allow-drop	拖拽时判定目标节点能否被放置。type 参数有三种情况：'prev'、'inner' 和 'next'，
                   分别表示放置在目标节点前、插入至目标节点和放置在目标节点后-->
          <el-card class="departments-tree">
            <el-tree :data="departs" node-key="id" default-expand-all>
              <!-- 作用域插槽 -->
              <!-- 传入插槽内容 使用 scoped slot 会传入两个参数node和data，分别表示当前节点的 Node 对象和当前节点的数据-->
              <!-- slot-scope="obj" 接受传给插槽的内容-->
              <!-- 引入组件 -->
              <treeTools
                slot-scope="{ data }"
                :treeNode="data"
                @deleteDepts="deleteDepts"
                @showAddDep="showAddDep"
              >
                <!-- 下拉菜单 -->
              </treeTools>
              <!-- 插槽内容 -->
            </el-tree>
          </el-card>
          <AddDepartment
            v-bind:showDialog.sync="showDialog"
            :treeNode="currentNode"
            @getData="getDepartmentsList"
          ></AddDepartment>
        </div>
      </div>
    </template>
    
    <script>
    import treeTools from "./components/treeTools.vue";
    import { getDepartments } from "@/api/departments";
    import { tranListToTree } from "@/utils";
    import AddDepartment from "./components/addDepartment.vue";
    export default {
      name: "Departments",
      components: {
        treeTools,
        AddDepartment,
      },
      data() {
        return {
          // 需要展示的上层结构
          company: {
            name: "组织架构管理",
            icon: "el-icon-office-building",
            manager: "负责人",
            type: "top",
            // 头部添加部门的时候，id是undefined,pid=''无法参与判断将要添加的部门是否重复
            id: "",
          },
          // 需要展示的下层结构
          departs: [],
          // 根据定义的属性查找节点，与data对应
          defaultProps: {
            children: "children",
            label: "name",
          },
          // 添加部门的弹窗
          showDialog: false,
          // 当前节点
          currentNode: {},
        };
      },
      mounted() {
        // 获取企业的部门列表
        this.getDepartmentsList();
      },
      methods: {
        // 获取企业的部门列表
        async getDepartmentsList() {
          let result = await getDepartments();
          let arr = tranListToTree(result.data.depts, "");
          this.departs = arr;
        },
    
        // 删除部门的自定义事件
        deleteDepts() {
          // 重新获取数据
          this.getDepartmentsList();
        },
    
        // 点击添加部门的事件
        showAddDep(value) {
          this.showDialog = true;
          // 记录当前节点
          this.currentNode = value;
        },
      },
    };
    </script>
    
    <style lang="less" scoped>
    .departments-head {
      /* 下拉菜单 */
      font-size: 14px;
      margin: 10px 0;
    }
    </style>
    ```
    
  * 可以通过两种方法进行树节点内容的自定义：`render-content`和 scoped slot
  
* 接口

  * ```js
    // 组织结构的相关请求
    import request from "@/utils/request";
    
    // 获取企业的部门列表
    export const getDepartments = () => {
      return request({ url: "/company/department" });
    };
    
    // 删除组织架构的部门
    export const delDepartment = (id) => {
      return request({
        url: `/company/department/${id}`,
        method: "delete",
      });
    };
    
    // 新增部门
    /**
     * 
     * @param {*} data 
     * code	string	非必须		部门编码，同级部门不可重复	
      introduce	string	非必须		介绍	
      manager	string	非必须		负责人名称	
      name	string	非必须		部门名称	
      pid	string	非必须		父级部门ID
     * 
     * 
     * @returns 
     */
    export const addDepartment = (data) => {
      return request({
        url: "/company/department",
        method: "post",
        data,
      });
    };
    
    // 获取某个部门的详情
    export const getDeptsDetail = (id) => {
      return request({
        url: `/company/department/${id}`,
      });
    };
    
    // 根据id修改部门详情
    export const updateDeptsDetail = (data) => {
      return request({
        url: `/company/department/${data.id}`,
        method: "put",
        data,
      });
    };
    
    // 获取员工的简单列表---用于选择负责人
    export const getSimpleUser = () => {
      return request({
        url: "/sys/user/simple",
      });
    };
    ```

* 将获取的组织架构转化为树形结构(后台返回的只是一个数组)

  * utils/index.js

    * ```js
      // 把数组转换为属性结构
      // 递归算法
      export function tranListToTree(list, rootnode) {
        // 用于存储节点信息
        let arr = [];
        list &&
          list.forEach((item) => {
            // 第一次传的rootnode是空
            // pid等于空，就是根节点
            if (item.pid == rootnode) {
              // 再去查找该节点的子节点
              // children 是子节点数组
              // pid==id就表示pid是id的子节点
              let children = tranListToTree(list, item.id);
              // 如果children.length不为空，表示有子节点
              if (children.length) {
                item.children = children;
              }
              // 把根节点推到数组中
              arr.push(item);
            }
          });
        // 返回该数组
        return arr;
      }
      ```

* 新增功能

  * 封装addDepartment.vue组件
  
  * ```vue
    <template>
      <div>
        <el-dialog
          title="请填写相关信息"
          :visible.sync="showDialog_2"
          width="40%"
          center
          :before-close="handleClose"
        >
          <el-form
            :model="mydata"
            label-width="100px"
            :rules="rules"
            ref="ruleForm"
          >
            <el-form-item label="部门名称" prop="name">
              <el-input v-model="mydata.name" placeholder="部门名称"></el-input>
            </el-form-item>
    
            <el-form-item label="部门编码" prop="code">
              <el-input v-model="mydata.code" placeholder="部门编码"></el-input>
            </el-form-item>
    
            <el-form-item label="部门负责人" prop="manager">
              <!-- 聚焦时获取员工列表 -->
              <el-select
                @focus="getSimpleUser"
                v-model="mydata.manager"
                placeholder="请选择"
              >
                <!-- 遍历员工列表 -->
                <el-option
                  v-for="users in userList"
                  :key="users.id"
                  :value="users.username"
                  >{{ users.username }}</el-option
                >
              </el-select>
            </el-form-item>
    
            <el-form-item label="部门介绍" prop="introduce">
              <el-input
                v-model="mydata.introduce"
                placeholder="部门介绍"
                type="textarea"
                :rows="3"
              ></el-input>
            </el-form-item>
          </el-form>
          <span slot="footer" class="dialog-footer">
            <el-button @click="closeDialog('cancel')">取 消</el-button>
            <el-button type="primary" @click="closeDialog('submit')"
              >确 定</el-button
            >
          </span>
        </el-dialog>
      </div>
    </template>
    
    <script>
    import { getDepartments, addDepartment } from "@/api/departments";
    import { getSimpleUser } from "@/api/employees";
    export default {
      name: "AddDepartment",
      props: {
        // 控制显示与隐藏
        showDialog: {
          type: Boolean,
          default: false,
        },
        // 当前节点
        treeNode: {
          type: Object,
          default: null,
        },
      },
      data() {
        // 定义部门名称同级不重复的校验规则
        const checkNameRepeat = async (rule, value, callback) => {
          // 获取所有的部门数组
          const result = await getDepartments();
          // 先找到子级部门，再从子级部门中查找是否已经存在
          // console.log(this.treeNode.id);
          const isRepeat = result.data.depts
            .filter((item) => item.pid == this.treeNode.id)
            .some((item) => item.name == value);
          isRepeat
            ? callback(new Error(`同级部门下已经有${value}部门了`))
            : callback();
        };
        // 定义部门编码全部级别不重复的校验规则
        const checkCodeRepeat = async (rule, value, callback) => {
          // 获取所有的部门数组
          const result = await getDepartments();
          const isRepeat = result.data.depts.some((item) => item.code == value);
          isRepeat ? callback(new Error("该编码已经存在了")) : callback();
        };
        return {
          //   表单数据
          mydata: {
            // 部门名称
            name: "",
            // 部门编码
            code: "",
            // 部门负责人
            manager: "",
            // 部门介绍
            introduce: "",
          },
          // 表单的校验规则
          rules: {
            name: [
              { required: true, message: "部门名称不能为空", trigger: "blur" },
              { min: 1, max: 20, message: "1-20个字符之间" },
              // 自定义校验规则
              { validator: checkNameRepeat, trigger: "blur" },
            ],
            code: [
              { required: true, message: "部门编码不能为空", trigger: "blur" },
              { min: 1, max: 20, message: "1-20个字符之间" },
              // 自定义校验规则
              { validator: checkCodeRepeat, trigger: "blur" },
            ],
            introduce: [
              { required: true, message: "部门介绍不能为空", trigger: "blur" },
              { min: 1, max: 20, message: "1-200个字符之间" },
            ],
            manager: [
              { required: true, message: "请选择活动区域", trigger: "change" },
            ],
          },
          //   拷贝一份props
          showDialog_2: this.showDialog,
          // 员工列表
          userList: [],
        };
      },
      methods: {
        // 对话框关闭前的回调
        handleClose() {
          // 清空校验规则，重置表单
          this.mydata = {
            // 部门名称
            name: "",
            // 部门编码
            code: "",
            // 部门负责人
            manager: "",
            // 部门介绍
            introduce: "",
          };
          // 重置校验规则
          this.$refs.ruleForm.clearValidate();
          // 通知父组件改变showDialog的值
          this.$emit("update:showDialog", false);
        },
        // 确认或关闭的回调
        closeDialog(type) {
          // 取消按钮的回调
          if (type == "cancel") {
            // 关闭对话框前的回调
            this.handleClose();
          } else {
            // 确定按钮的回调
            // 进行表单校验
            // 获取表单实例
            this.$refs.ruleForm.validate(async (isOk) => {
              if (isOk) {
                // 表单校验通过
                await addDepartment({ ...this.mydata, pid: this.treeNode.id });
                // 通知父组件重新渲染数据
                this.$emit("getData");
                // 关闭对话框前的回调
                this.handleClose();
              }
            });
          }
        },
        // 获取简单员工列表
        async getSimpleUser() {
          let result = await getSimpleUser();
          if (result.success) {
            // 有的可能没有username
            this.userList = result.data.filter((item) => item.username);
          }
          // console.log(result);
        },
      },
      mounted() {
        // console.log(this.treeNode);
      },
      watch: {
        // 检测props的变化，更新this.showDialog_2
        showDialog: function (val) {
          this.showDialog_2 = val;
        },
      },
    };
    </script>
    
    <style>
    </style>
    ```
  
  * addDepartment.vue组件的显示隐藏控制(.sync修饰符)
  
    * treeTools中触发添加部门事件
  
      * ```vue
        methods: {
            // 下拉菜单的点击事件
            handleCommand(command) {
              // command 判断是 添加add 删除delete 编辑edit
              // console.log(command);
              if (command == "add") {
                console.log("add");
                // 通知父组件弹出添加部门的表单，并把当前的数据对象传递过去
         +       this.$emit("showAddDep", this.treeNode);}
        ```
  
    * index中接受该事件，并控制对话框组件的显示与隐藏
  
      * ```vue
        <treeTools :treeNode="company" @showAddDep="showAddDep"> </treeTools>
        // 对话框组件 利用.sync修饰符实现数据的双向绑定
        <AddDepartment v-bind:showDialog.sync="showDialog"></AddDepartment>
        ```
  
      
  
* 删除功能

  * treeTools.vue
    
    * ```vue
      // 下拉菜单的点击事件
          handleCommand(command) {
            // command 判断是 添加add 删除delete 编辑edit
            
            if (command == "add") {
              // 通知父组件弹出添加部门的表单，并把当前的数据对象传递过去
              this.$emit("showAddDep", this.treeNode);
      
            } else if (command == "delete") {
              
              // 调用elementui的弹框
              this.$confirm("此操作将删除该部门, 是否继续?", "提示", {
                confirmButtonText: "确定",
                cancelButtonText: "取消",
                type: "warning",
                center: true,
              })
                .then(() => {
                  // 删除的回调
                  // 调用删除的api
                  return delDepartment(this.treeNode.id);
                })
                .then(() => {
                  // 如果调用删除接口成功
                  // 通知父组件重新获取数据
                  this.$emit("deleteDepts");
                  this.$message({
                    type: "success",
                    message: "删除成功!",
                  });
                });
            } else {
              console.log("edit");
            }
          },
      ```
    
  * index.vue

    * ```vue
      <treeTools
        slot-scope="{ data }"
        :treeNode="data"
        @deleteDepts="deleteDepts"
        @showAddDep="showAddDep"
      >
      </treeTools>
          // 删除部门的自定义事件
          deleteDepts() {
            // 重新获取数据
            this.getDepartmentsList();
          },
      ```

* 编辑功能和新增共用addDepartment组件

  > 根据传入的值是否含有id判断是编辑还是新增，编辑和新增要用两个不同的校验规则

  * addDepartment.vue

    * ```vue
      <template>
        <!-- 添加和编辑部门 -->
        <div>
          <!-- 根据mydata中是否有id判断是新增还是编辑 -->
          <el-dialog
            :title="mydata.id ? `编辑${mydata.name}` : '新增部门'"
            :visible.sync="showDialog_2"
            width="40%"
            center
            :before-close="handleClose"
          >
            <el-form
              :model="mydata"
              label-width="100px"
              :rules="rules"
              ref="ruleForm"
            >
              <el-form-item label="部门名称" prop="name">
                <el-input v-model="mydata.name" placeholder="部门名称"></el-input>
              </el-form-item>
      
              <el-form-item label="部门编码" prop="code">
                <el-input v-model="mydata.code" placeholder="部门编码"></el-input>
              </el-form-item>
      
              <el-form-item label="部门负责人" prop="manager">
                <!-- 聚焦时获取员工列表 -->
                <el-select
                  @focus="getSimpleUser"
                  v-model="mydata.manager"
                  placeholder="请选择"
                >
                  <!-- 遍历员工列表 -->
                  <el-option
                    v-for="users in userList"
                    :key="users.id"
                    :value="users.username"
                    >{{ users.username }}</el-option
                  >
                </el-select>
              </el-form-item>
      
              <el-form-item label="部门介绍" prop="introduce">
                <el-input
                  v-model="mydata.introduce"
                  placeholder="部门介绍"
                  type="textarea"
                  :rows="3"
                ></el-input>
              </el-form-item>
            </el-form>
            <span slot="footer" class="dialog-footer">
              <el-button @click="closeDialog('cancel')">取 消</el-button>
              <el-button type="primary" @click="closeDialog('submit')"
                >确 定</el-button
              >
            </span>
          </el-dialog>
        </div>
      </template>
      
      <script>
      import {
        getDepartments,
        addDepartment,
        getDeptsDetail,
        updateDeptsDetail,
      } from "@/api/departments";
      import { getSimpleUser } from "@/api/employees";
      export default {
        name: "AddDepartment",
        props: {
          // 控制显示与隐藏
          showDialog: {
            type: Boolean,
            default: false,
          },
          // 当前节点
          treeNode: {
            type: Object,
            default: null,
          },
        },
        data() {
          // 定义部门名称同级不重复的校验规则
          const checkNameRepeat = async (rule, value, callback) => {
            // 获取所有的部门数组，防止有些数据被删除
            const result = await getDepartments();
            // 先找到子级部门，再从子级部门中查找是否已经存在
            // console.log(this.treeNode.id);
      
            // 默认的校验结果
            let isRepeat = false;
            // 两种不同的校验规则 添加 和 编辑
            if (this.mydata.id) {
              // 编辑模式
              // 找到同级的所有部门，然后排除掉自己，再去判断是否有重名的情况
              isRepeat = result.data.depts
                .filter(
                  (item) => item.pid == this.mydata.pid && item.id !== this.mydata.id
                )
                .some((item) => item.name == this.mydata.name);
            } else {
              // 添加模式
              isRepeat = result.data.depts
                .filter((item) => item.pid == this.treeNode.id)
                .some((item) => item.name == value);
            }
      
            isRepeat
              ? callback(new Error(`同级部门下已经有${value}部门了`))
              : callback();
          };
      
          // 定义部门编码全部级别不重复的校验规则
          const checkCodeRepeat = async (rule, value, callback) => {
            // 获取所有的部门数组
            const result = await getDepartments();
            // 默认的校验结果
            let isRepeat = false;
            // 两种不同的校验规则 添加 和 编辑
            if (this.mydata.id) {
              // 编辑模式
              // 找到同级的所有部门，然后排除掉自己，再去判断是否有相同的编码情况
              isRepeat = result.data.depts
                .filter((item) => item.id !== this.mydata.id)
                .some((item) => item.code == value);
            } else {
              // 添加模式
              isRepeat = result.data.depts.some((item) => item.code == value);
            }
            isRepeat ? callback(new Error("该编码已经存在了")) : callback();
          };
      
          return {
            //   表单数据
            mydata: {
              // 部门名称
              name: "",
              // 部门编码
              code: "",
              // 部门负责人
              manager: "",
              // 部门介绍
              introduce: "",
            },
            // 表单的校验规则
            rules: {
              name: [
                { required: true, message: "部门名称不能为空", trigger: "blur" },
                { min: 2, max: 20, message: "1-20个字符之间" },
                // 自定义校验规则
                { validator: checkNameRepeat, trigger: "blur" },
              ],
              code: [
                { required: true, message: "部门编码不能为空", trigger: "blur" },
                { min: 1, max: 20, message: "1-20个字符之间" },
                // 自定义校验规则
                { validator: checkCodeRepeat, trigger: "blur" },
              ],
              introduce: [
                { required: true, message: "部门介绍不能为空", trigger: "blur" },
                { min: 1, max: 20, message: "1-200个字符之间" },
              ],
              manager: [
                { required: true, message: "请选择活动区域", trigger: "change" },
              ],
            },
            //   拷贝一份props
            showDialog_2: this.showDialog,
            // 员工列表
            userList: [],
          };
        },
        methods: {
          // 对话框关闭前的回调
          handleClose() {
            // 清空校验规则，重置表单
            this.mydata = {
              // 部门名称
              name: "",
              // 部门编码
              code: "",
              // 部门负责人
              manager: "",
              // 部门介绍
              introduce: "",
            };
            // 重置校验规则
            this.$refs.ruleForm.clearValidate();
            // 通知父组件改变showDialog的值
            this.$emit("update:showDialog", false);
          },
      
          // 确认或关闭按钮的回调
          closeDialog(type) {
            // 取消按钮的回调
            if (type == "cancel") {
              // 关闭对话框前的回调
              this.handleClose();
            } else {
              // 确定按钮的回调
              // 进行表单校验
              // 获取表单实例
              this.$refs.ruleForm.validate(async (isOk) => {
                // 表单校验通过
                if (isOk) {
                  if (this.mydata.id) {
                    // 修改数据
                    // 校验模式需要更改
                    await updateDeptsDetail(this.mydata);
                  } else {
                    // 新增数据
                    await addDepartment({ ...this.mydata, pid: this.treeNode.id });
                  }
                  // 通知父组件重新渲染数据
                  this.$emit("getData");
                  // 关闭对话框前的回调
                  this.handleClose();
                }
              });
            }
          },
          // 获取简单员工列表
          async getSimpleUser() {
            let result = await getSimpleUser();
            if (result.success) {
              // 有的可能没有username
              this.userList = result.data.filter((item) => item.username);
            }
            // console.log(result);
          },
      
          // 获取部门的详情，用于编辑部门,夫组件调用
          async getDeptsDetails(id) {
            let result = await getDeptsDetail(id);
            this.mydata = result.data;
            console.log(this.mydata);
            // id不能在这里使用props的treenode，因为props传值是异步的，不一定能拿到值
            // 把获取到的详情数据赋值给mydata在页面上回显
          },
        },
        mounted() {
          // console.log(this.treeNode);
        },
        watch: {
          // 检测props的变化，更新this.showDialog_2
          showDialog: function (val) {
            this.showDialog_2 = val;
          },
        },
      };
      </script>
      
      <style>
      </style>
      ```

  * index.vue

    * ```vue
       // 编辑部门的回调
          editDepts(node) {
            // console.log(node);
            this.currentNode = node;
            // 弹出对话框，和添加部门使用同一个组件
            this.showDialog = true;
            // 在这里调用子组件的获取部门详情的方法，
            this.$refs.adddepartment.getDeptsDetails(node.id);
          },
      ```

  * treeTools.vue

    * ```vue
      // 编辑部门
       this.$emit("editDepts", this.treeNode);
      ```

#### 公司设置页面的搭建

* api接口

  * ```js
    // 公司设置管理
    
    import request from "@/utils/request";
    
    // 角色管理
    // 获取全部角色列表
    // params
    // page	是	1	页码
    // pagesize	是	10	每页条数
    export const getRoleList = (params) => {
      return request({
        url: "/sys/role",
        params,
      });
    };
    
    /**
     * 删除角色
     * @param {*} id 用户id
     * @returns
     */
    export const deleteRoleById = (id) => {
      return request({
        url: `/sys/role/${id}`,
        method: "delete",
      });
    };
    
    /**
     * 根据id获取角色详情
     * @param {*} id
     * @returns
     */
    export const getroleDetail = (id) => {
      return request({
        url: `/sys/role/${id}`,
      });
    };
    /**
     * 根据Id修改角色信息
     * @param {*} id
     * data:{
     * companyId	string	必须		公司id	
       description	string	必须		描述	
       id	string	必须		标识	
       name	string	必须		角色名称	
       permIds	string []	必须		权限点数据	
       item 类型: string
     * }
     * @returns
     */
    export const updateRole = (data) => {
      return request({
        url: `/sys/role/${data.id}`,
        method: "put",
        data,
      });
    };
    
    /**
     * 新增角色功能
     * @param {} data{name,des}
     * @returns
     */
    export const addRoles = (data) => {
      return request({
        url: "/sys/role",
        method: "post",
        data,
      });
    };
    
    ```

##### 角色设置

* 页面

  * ```vue
    <template>
      <div class="dashboard-container">
        <div class="app-container">
          <el-card>
            <el-tabs v-model="activeName" @tab-click="handleClick">
              <el-tab-pane label="角色管理" name="first">
                <!-- 新增角色 -->
                <el-button type="primary" @click="addRole">+ 新增角色</el-button>
                <!-- 角色表格 -->
                <el-table
                  :data="list"
                  border
                  style="width: 100%; margin: 20px 0; text-align: center"
                >
                  <el-table-column
                    type="index"
                    label="序号"
                    width="150"
                    align="center"
                    header-align="center"
                  >
                  </el-table-column>
                  <el-table-column
                    prop="name"
                    label="名称"
                    width="200"
                    header-align="center"
                  >
                  </el-table-column>
                  <el-table-column
                    prop="description"
                    label="描述"
                    width="300"
                    header-align="center"
                  >
                  </el-table-column>
                  <el-table-column
                    prop="operate"
                    label="操作"
                    header-align="center"
                  >
                    <!-- 作用域插槽，可以获取每行的数据 -->
                    <!-- 通过 Scoped slot 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据 -->
                    <template slot-scope="scope">
                      <el-button type="success" size="medium">分配权限</el-button>
                      <el-button
                        type="primary"
                        size="small"
                        @click="editRole(scope.row)"
                        >编辑</el-button
                      >
                      <el-button
                        type="danger"
                        size="small"
                        @click="deleterole(scope.row.id)"
                        >删除</el-button
                      >
                    </template>
                  </el-table-column>
                </el-table>
                <!-- 分页器 -->
                <Pagination
                  :total="total"
                  :currentpage="page.page"
                  :pagesize="page.pagesize"
                  @changepages="changepages"
                ></Pagination>
              </el-tab-pane>
              <el-tab-pane label="公司信息" name="second">
                <!-- alert警告组件 -->
                <el-alert
                  title="对公司名称、地址、营业执照、地区的更新,将使的公司资料被重新审核，请谨慎修改"
                  type="info"
                  style="margin: 10px 0"
                  show-icon
                  :closable="false"
                >
                </el-alert>
                <!-- 表单 -->
                <el-form
                  label-position="right"
                  label-width="80px"
                  :model="companyForm"
                >
                  <el-form-item label="企业名称">
                    <el-input disabled v-model="companyForm.name"></el-input>
                  </el-form-item>
                  <el-form-item label="公司地址">
                    <el-input disabled v-model="companyForm.address"></el-input>
                  </el-form-item>
                  <el-form-item label="电话">
                    <el-input disabled v-model="companyForm.phone"></el-input>
                  </el-form-item>
                  <el-form-item label="邮箱">
                    <el-input disabled v-model="companyForm.email"></el-input>
                  </el-form-item>
                  <el-form-item label="备注">
                    <el-input
                      type="textarea"
                      :rows="3"
                      disabled
                      v-model="companyForm.remark"
                    ></el-input>
                  </el-form-item>
                </el-form>
              </el-tab-pane>
            </el-tabs>
          </el-card>
        </div>
        <!-- 对话框组件 -->
        <roleDialog
          v-bind:showdialog.sync="showdialog"
          :roleDetail="roleDetail"
          @updateData="getRoleList(page)"
        ></roleDialog>
      </div>
    </template>
    
    <script>
    import roleDialog from "./components/roleDialog.vue";
    import { getRoleList, deleteRoleById, getroleDetail } from "@/api/setting";
    export default {
      name: "Setting",
      components: {
        roleDialog,
      },
      data() {
        return {
          // 接受角色列表
          list: [],
          // 总数据条数
          total: 0,
          page: {
            // 放置页码等
            // 当前页
            page: 1,
            // 页面尺寸
            pagesize: 1,
          },
          // element-ui的标签页组件默认激活
          activeName: "first",
          // 控制编辑和添加对话框的显示与隐藏
          showdialog: false,
          // 角色的详细信息
          roleDetail: {},
          // 公司信息
          companyForm: {
            name: "",
            address: "",
            phone: "",
            email: "",
            remark: "",
          },
        };
      },
      methods: {
        // 获取角色列表的方法
        async getRoleList(page) {
          // 是否传入默认值
          let pages = page ? page : this.page;
          let result = await getRoleList(pages);
          if (result.success) {
            this.total = result.data.total;
            this.list = result.data.rows;
          }
        },
        // tabs组件的点击事件
        handleClick(tab, event) {
          console.log(tab, event);
        },
        // 分页组件的自定义事件
        changepages(pages) {
          // console.log(pages);
          this.page.page = pages.page;
          this.page.pagesize = pages.pagesize;
          this.getRoleList(pages);
        },
        // 删除角色信息
        async deleterole(id) {
          // 提示对话框
          try {
            // console.log(id);
            await this.$confirm("确认删除角色吗");
            // 确认删除
            await deleteRoleById(id);
          } catch (error) {
            // 取消删除
          }
          this.getRoleList();
        },
        // 点击编辑角色信息
        async editRole(value) {
          // 获取角色的详情信息
          let result = await getroleDetail(value.id);
          console.log(result);
          if (result.success) {
            this.roleDetail = result.data;
            // 显示对话框
            this.showdialog = true;
          }
        },
        // 新增角色
        addRole() {
          // 显示对话框
          this.showdialog = true;
        },
      },
      mounted() {
        // 调用方法获取角色列表
        this.getRoleList();
      },
    };
    </script>
    
    <style>
    </style>
    ```

* 删除操作

  * ```vue
      <!-- 作用域插槽，可以获取每行的数据 -->
                    <!-- 通过 Scoped slot 可以获取到 row, column, $index 和 store（table 内部的状态管理）的数据 -->
                    <template slot-scope="scope">
                      <el-button type="success" size="medium">分配权限</el-button>
                      <el-button type="primary" size="small">编辑</el-button>
                      <el-button
                        type="danger"
                        size="small"
                        @click="deleterole(scope.row.id)"
                        >删除</el-button
                      >
                    </template>
    ```

  * ```js
    import { deleteRoleById } from "@/api/setting";
    // 删除角色信息
        async deleterole(id) {
          // 提示对话框
          try {
            // console.log(id);
            await this.$confirm("确认删除角色吗");
            // 确认删除
            await deleteRoleById(id);
          } catch (error) {
            // 取消删除
          }
          this.getRoleList();
        },
    ```

* 新增和编辑功能

  * setting/index.vue

    * ```vue
       // 点击编辑角色信息
          async editRole(value) {
            // 获取角色的详情信息
            let result = await getroleDetail(value.id);
            console.log(result);
            if (result.success) {
              this.roleDetail = result.data;
              // 显示对话框
              this.showdialog = true;
            }
          },
          // 新增角色
          addRole() {
            // 显示对话框
            this.showdialog = true;
          },
      ```

  * 对话框组件``setting/components/roleDialog``

    * ```vue
      <template>
        <el-dialog
          :title="roledetails.id ? '编辑部门' : '新增部门'"
          :visible.sync="showdialog_2"
          width="50%"
          center
          :before-close="closeDialog"
        >
          <!-- 表单 -->
          <el-form
            label-position="right"
            label-width="80px"
            :model="roledetails"
            :rules="rules"
            ref="ruleForm"
          >
            <el-form-item label="角色名称" prop="name">
              <el-input v-model="roledetails.name"></el-input>
            </el-form-item>
            <el-form-item label="角色描述">
              <el-input v-model="roledetails.description"></el-input>
            </el-form-item>
          </el-form>
      
          <!-- 底部按钮 -->
          <span slot="footer" class="dialog-footer">
            <el-button @click="changeshowdialog('false')">取 消</el-button>
            <el-button type="primary" @click="changeshowdialog('true')"
              >确 定</el-button
            >
          </span>
        </el-dialog>
      </template>
      
      <script>
      import { updateRole, addRoles } from "@/api/setting";
      export default {
        name: "roleDialog",
        props: {
          // 控制对话框的显示与隐藏
          showdialog: {
            type: Boolean,
            default: false,
          },
          // 角色的详细信息
          roleDetail: {
            type: Object,
            default: () => {},
          },
        },
        data() {
          return {
            // 显示
            showdialog_2: false,
            //   表单收集的数据
            roledetails: {},
            //   name的校验
            rules: {
              name: [
                { required: true, message: "角色名称不能为空", trigger: "blur" },
              ],
            },
          };
        },
        methods: {
          // 点击确认或者取消的回调
          changeshowdialog(flag) {
            if (flag == "true") {
              // 确认的回调
              // 表单的校验
              this.$refs.ruleForm.validate(async (isOk) => {
                // 表单校验成功
                if (isOk) {
                  //  如果包含id是编辑功能，没有是新增功能
                  if (this.roledetails.id) {
                    // 编辑
                    // 提交修改
                    // 整理参数
                    /* 
                  companyId	string	必须		公司id	
                  description	string	必须		描述	
                  id	string	必须		标识	
                  name	string	必须		角色名称	
                  permIds	string []	必须		权限点数据	
                  item 类型: string
              */
                    let result = await updateRole(this.roledetails);
                    if (result.success) {
                      this.$message.success("操作成功");
                    }
                    // 通知父组件更新数据
                    this.$emit("updateData");
                  } else {
                    // 新增
                    let results = await addRoles(this.roledetails);
                    if (results.success) {
                      // 通知父组件更新数据
                      this.$emit("updateData");
                    }
                  }
                  this.closeDialog();
                }
              });
            } else {
              // 取消的回调
              this.closeDialog();
            }
          },
      
          // 关闭前的回调
          closeDialog() {
            // console.log(1);
            //   重置表单
            this.roledetails = {};
            this.$emit("update:showdialog", false);
            this.$refs.ruleForm.resetFields();
          },
        },
      
        watch: {
          roleDetail: {
            handler: function () {
              this.roledetails = this.roleDetail;
            },
            immediate: true,
          },
          showdialog: {
            handler: function (val) {
              this.showdialog_2 = val;
            },
            immediate: true,
          },
        },
      };
      </script>
      
      <style>
      </style>
      ```

* 权限管理

##### 公司设置

* setting/index.vue

  * ```vue
              <el-tab-pane label="公司信息" name="second">
                <!-- alert警告组件 -->
                <el-alert
                  title="对公司名称、地址、营业执照、地区的更新,将使的公司资料被重新审核，请谨慎修改"
                  type="info"
                  style="margin: 10px 0"
                  show-icon
                  :closable="false"
                >
                </el-alert>
                <!-- 表单 -->
                <el-form
                  label-position="right"
                  label-width="80px"
                  :model="companyForm"
                >
                  <el-form-item label="企业名称">
                    <el-input disabled v-model="companyForm.name"></el-input>
                  </el-form-item>
                  <el-form-item label="公司地址">
                    <el-input disabled v-model="companyForm.address"></el-input>
                  </el-form-item>
                  <el-form-item label="电话">
                    <el-input disabled v-model="companyForm.phone"></el-input>
                  </el-form-item>
                  <el-form-item label="邮箱">
                    <el-input disabled v-model="companyForm.email"></el-input>
                  </el-form-item>
                  <el-form-item label="备注">
                    <el-input
                      type="textarea"
                      :rows="3"
                      disabled
                      v-model="companyForm.remark"
                    ></el-input>
                  </el-form-item>
                </el-form>
              </el-tab-pane>
    ```

#### 角色管理模块的搭建

##### 主页

* ```vue
  ```

##### 接口

* ```js
  ```

##### 删除员工

* employees/index

  * ```vue
                <!-- 利用作用域插槽获取用户的信息 -->
                <template slot-scope="{ row }">
    <el-button type="text" size="small" @click="delEmployees(row)"
                    >删除</el-button
                  >
                </template>
    // 引入接口
    import { getEmployeesList, delEmployees } from "@/api/employees";
    
    <script>
        // 根据id删除角色
        async delEmployees(row) {
          // console.log(row);
          // trycatch可以捕获取消
          try {
            await this.$confirm("确定要删除？");
            await delEmployees(row.id);
            this.$message.success("删除成功");
                    // 有问题
            this.getEmployeesList();
          } catch (error) {
            console.log(error);
          }
        },
    </script>
    ```
  
* 有个bug，删除员工成功之后，分页器无法回到上一页，上一页的页码无法被激活

##### 新建员工

* 新建员工的弹层

  * ```vue
    <template>
      <el-dialog
        title="新增员工"
        :visible.sync="isshow_2"
        :before-close="beforeClose"
        center
      >
        <el-form :model="list" label-width="120px" ref="ruleForm" :rules="rules">
          <el-form-item label="姓名" prop="username">
            <el-input
              v-model="list.username"
              placeholder="请输入姓名"
              style="width: 80%"
            ></el-input>
          </el-form-item>
          <el-form-item label="手机" prop="mobile">
            <el-input
              v-model="list.mobile"
              placeholder="请输入手机"
              style="width: 80%"
            ></el-input>
          </el-form-item>
          <el-form-item label="入职时间" prop="timeOfEntry">
            <el-date-picker
              v-model="list.timeOfEntry"
              placeholder="请选择入职时间"
              style="width: 80%"
            ></el-date-picker>
          </el-form-item>
          <el-form-item label="聘用形式" prop="formOfEmployment">
            <el-select v-model="list.formOfEmployment" placeholder="请选择聘用形式">
              <el-option
                v-for="item in employees.hireType"
                :key="item.id"
                :value="item.id"
                >{{ item.value }}</el-option
              >
            </el-select>
          </el-form-item>
          <el-form-item label="工号" prop="workNumber">
            <el-input
              v-model="list.workNumber"
              placeholder="请输入工号"
              style="width: 80%"
            ></el-input>
          </el-form-item>
          <el-form-item label="部门" prop="departmentName">
            <el-input
              v-model="list.departmentName"
              placeholder="请输入部门"
              style="width: 80%"
              @focus="getDepartments"
            ></el-input>
            <!-- 加载部门数据生成树形结构 -->
            <!-- 树形组件  
                  default-expand-all 默认全部展开
            -->
            <el-tree
              v-loading="loading"
              v-show="showtree"
              :data="treedata"
              :props="{ label: 'name' }"
              default-expand-all
              @node-click="handleNodeClick"
            ></el-tree>
          </el-form-item>
          <el-form-item label="转正时间" prop="correctionTime">
            <el-date-picker
              v-model="list.correctionTime"
              placeholder="请选择转正时间"
              style="width: 80%"
            ></el-date-picker>
          </el-form-item>
        </el-form>
        <!-- 底部按钮 -->
        <span slot="footer" class="dialog-footer">
          <el-button @click="changeshow('false')">取 消</el-button>
          <el-button type="primary" @click="changeshow('true')">确 定</el-button>
        </span>
      </el-dialog>
    </template>
    
    <script>
    import { addEmployee } from "@/api/employees";
    import { getDepartments } from "@/api/departments";
    import { tranListToTree } from "@/utils/index.js";
    // 注意，这只是引入了一个变量，并不能直接使用，需要在data中定义
    import employees from "@/api/constant/employees.js";
    export default {
      name: "addEmployees",
      props: {
        isshow: {
          type: Boolean,
          default: false,
        },
      },
      data() {
        return {
          //   显示与隐藏
          //   isshow_2: false,
          // 收集的员工信息
          list: {
            username: "",
            mobile: "",
            timeOfEntry: "",
            formOfEmployment: "",
            workNumber: "",
            departmentName: "",
            correctionTime: "",
          },
          //   验证规则
          rules: {
            username: [
              { required: true, message: "姓名不能为空", trigger: "blur" },
              { min: 1, max: 4, message: "姓名在1-4位", trigger: "blur" },
            ],
            mobile: [
              { required: true, message: "手机不能为空", trigger: "blur" },
              {
                pattern: /^1[3-9]\d{9}$/,
                message: "手机号格式不正确",
                trigger: "blur",
              },
            ],
            timeOfEntry: [
              { required: true, message: "入职时间不能为空", trigger: "blur" },
            ],
            formOfEmployment: [
              { required: true, message: "聘用形式不能为空", trigger: "blur" },
            ],
            workNumber: [
              { required: true, message: "工号不能为空", trigger: "blur" },
            ],
            departmentName: [
              { required: true, message: "部门不能为空", trigger: "change" },
            ],
            correctionTime: [
              { required: true, message: "转正时间不能为空", trigger: "blur" },
            ],
          },
    
          // 收集树形结构数据
          treedata: [],
          // 控制树形结构的显示
          showtree: false,
          // loading效果
          loading: false,
          // 招聘形式所对应的数据
          employees: employees,
        };
      },
      computed: {
        // 利用计算属性复制一份props使用
        isshow_2: function () {
          return this.isshow;
        },
      },
    
      methods: {
        // 对话框关闭前的回调
        beforeClose() {
          // 清空表单
          this.list = {
            username: "",
            mobile: "",
            timeOfEntry: "",
            formOfEmployment: "",
            workNumber: "",
            departmentName: "",
            correctionTime: "",
          };
          this.loading = false;
          this.showtree = false;
          //   清空验证规则
          this.$refs.ruleForm.resetFields();
          //   更新父组件的isshow
          this.$emit("update:isshow", false);
        },
    
        // 确认和取消按钮的回调
        changeshow(flag) {
          if (flag == "true") {
            // 确认按钮的回调
            // 表单验证
            this.$refs.ruleForm.validate(async (isOk) => {
              if (isOk) {
                // 验证成功
                await addEmployee(this.list);
                this.$message.success("添加成功");
                // 通知父组件更新数据
                this.$emit("updateemployees");
                this.beforeClose();
              }
            });
          } else {
            // 取消按钮的回调
            this.beforeClose();
          }
        },
    
        // 获取部门的树形结构
        async getDepartments() {
          this.loading = true;
          this.showtree = true;
          let result = await getDepartments();
          // '' 表示一级部门,将数组转换为树形结构
          this.treedata = tranListToTree(result.data.depts, "");
          this.loading = false;
        },
    
        // 收集树形结构数据，树形节点被点击的回调
        handleNodeClick(data, node, mynode) {
          // 共三个参数，依次为：传递给 data 属性的数组中该节点所对应的对象、节点对应的 Node、节点组件本身vue组件实例。
          // console.log(data, node, mynode);
          this.list.departmentName = data.name;
          // 隐藏树形结构
          this.showtree = false;
        },
      },
    
      //   watch: {
      //     isshow: {
      //       handler: function (val) {
      //         this.isshow_2 = val;
      //       },
      //       immediate: true,
      //     },
      //   },
    };
    </script>
    
    <style>
    </style>
    ```

* employees/index   触发开启弹层

  * ```js
     // 新增员工
        addemployee() {
          this.isshow = true;
        },
        // 添加成功重新更新数据
        updateemployees() {
          this.getEmployeesList();
        }
    ```

* 添加路由动画


### 封装公共组件

#### 工具栏组件

* ```vue
  <template>
    <!-- 通用的工具栏插槽 -->
    <el-card class="pagetool">
      <el-row type="flex" align="middle" justify="space-between">
        <el-col>
          <div class="before" v-if="showBefore">
            <!-- 图标 -->
            <i class="el-icon-info" style="color: blue"></i>
            <!-- 具名插槽 -->
            <slot name="before">adad</slot>
          </div>
        </el-col>
        <el-col>
          <!-- 靠右对齐 -->
          <el-row type="flex" justify="end">
            <slot name="after">111</slot>
          </el-row>
        </el-col>
      </el-row>
    </el-card>
  </template>
  
  <script>
  export default {
    name: "PageTool",
    props: {
      // 控制是否显示前面的div
      showBefore: {
        type: Boolean,
        default: false,
      },
    },
  };
  </script>
  
  <style lang="less" scoped>
  .pagetool {
    margin: 10px;
    .before {
      padding: 0 15px;
      line-height: 34px;
      // 原来是占满的
      display: inline-block;
      border-radius: 5px;
      border: 1px solid rgba(145, 213, 255, 1);
      background-color: rgb(230, 247, 255, 1);
      i {
        padding-right: 5px;
      }
    }
  }
  </style>
  ```



#### 分页组件

* ```vue
  <template>
    <!-- 分页器组件 -->
    <div class="pagination">
      <!-- 总数目 -->
      <div class="total">共{{ total }}条</div>
      <div class="container">
        <!-- 上一页 -->
        <button
          class="pre disabled"
          @click="changePage(myCurrentPage - 1)"
          v-if="myCurrentPage == 1"
        >
          &lt;
        </button>
        <button class="pre" @click="changePage(myCurrentPage - 1)" v-else>
          &lt;
        </button>
        <!-- 页码 -->
        <!-- <span>1</span>
        <span>...</span>
        <span>2</span>
        <span>2</span>
        <span>...</span>
        <span>3</span> -->
        <span
          v-show="startAndEndPages().start > 1"
          @click="changePage(1)"
          :class="{ active: myCurrentPage == 1 }"
          >1</span
        >
  
        <span v-show="startAndEndPages().start > 1">...</span>
  
        <!-- 注意template不能绑定key -->
        <template v-for="(page, index) in startAndEndPages().end">
          <span
            :class="{ active: myCurrentPage == page }"
            v-if="page >= startAndEndPages().start"
            :key="index"
            @click="changePage(page)"
            >{{ page }}</span
          >
        </template>
  
        <span v-show="startAndEndPages().end < totalPage">...</span>
  
        <span
          v-show="startAndEndPages().end < totalPage"
          @click="changePage(totalPage)"
          :class="{ active: myCurrentPage == totalPage }"
          >{{ totalPage }}</span
        >
        <!-- 下一页 -->
        <button
          class="next disabled"
          @click="changePage(myCurrentPage + 1)"
          v-if="myCurrentPage == totalPage"
        >
          &gt;
        </button>
        <button class="next" @click="changePage(myCurrentPage + 1)" v-else>
          &gt;
        </button>
      </div>
      <!-- 页面尺寸 -->
      <!-- @change="selectClass($event)" -->
      <select class="pagesize" @change="selectClass($event)">
        <option value="1" selected>1条/页</option>
        <option value="5">5条/页</option>
        <option value="10">10条/页</option>
      </select>
      <!-- 直接前往第几页 -->
      <div class="goPage">
        前往<input
          type="text"
          placeholder="1"
          v-model.number="goPage"
          @keyup.enter="changePage(goPage)"
        />页
      </div>
    </div>
  </template>
  
  <script>
  export default {
    name: "Pagination",
    props: {
      total: {
        type: Number,
        default: 100,
      },
      currentpage: {
        type: Number,
        default: 1,
      },
      pagesize: {
        type: Number,
        default: 1,
      },
      // 连续页数
      limit: {
        type: Number,
        default: 5,
      },
    },
    data() {
      return {
        // 下拉框收集的数据
        selectClassEnd: 1,
        // 去那一页
        goPage: 1,
        // 定义props的代理
        myTotal: 100,
        myPageSize: 1,
        myCurrentPage: 1,
        myLimit: 5,
      };
    },
    computed: {
      // 计算总页数
      totalPage() {
        return Math.ceil(this.total / this.pagesize);
      },
    },
    methods: {
      // 计算开始页和结束页
      startAndEndPages() {
        // 开始页和结束页
        let start = 0;
        let end = 0;
        // 如果总页数小于连续页数
        if (this.totalPage < this.myLimit) {
          start = 1;
          end = this.totalPage;
        } else {
          // 总页数大于连续页数
          // 需要让当前页在中间
          start = this.myCurrentPage - parseInt(this.myLimit / 2);
          end = start + this.myLimit - 1;
          // 如果start小于1
          if (start < 1) {
            start = 1;
            // end是否可能超出
            end =
              start + this.myLimit - 1 > this.totalPage
                ? this.totalPage
                : start + this.myLimit - 1;
          }
          // end超过总页数
          if (end > this.totalPage) {
            end = this.totalPage;
            // 判断start是否小于1
            start = end - this.myLimit + 1 < 1 ? 1 : end - this.myLimit + 1;
          }
        }
  
        return { start, end };
      },
  
      // 改变页码
      changePage(page) {
        if (page <= 0 || page > this.totalPage) {
          alert("页码不正确");
          return;
        }
        if (this.myCurrentPage !== page) {
          this.myCurrentPage = page;
          // 通知父组件更改页码
          // 整理参数
          let pages = { page: this.myCurrentPage, pagesize: this.myPageSize };
          this.$emit("changepages", pages);
        }
        this.goPage = 1;
      },
  
      // 改变页面尺寸
      selectClass(e) {
        // e.target.value 是你选中的值
        this.myPageSize = parseInt(e.target.value);
        this.myCurrentPage = 1;
        this.goPage = 1;
        // 通知父组件更改页码
        // 通知父组件更改页码
        // 整理参数
        let pages = { page: this.myCurrentPage, pagesize: this.myPageSize };
        this.$emit("changepages", pages);
        // console.log(e.target.value);
      },
    },
    mounted() {},
    watch: {
      props: {
        handler() {
          this.myTotal = this.total;
          this.myPageSize = this.pagesize;
          this.myCurrentPage = this.currentpage;
          this.myLimit = this.limit;
        },
        immediate: true,
      },
    },
  };
  </script>
  
  <style lang="less" scoped>
  .pagination {
    width: 800px;
    height: 30px;
    line-height: 30px;
    font-size: 14px;
    margin: 5px auto;
    display: flex;
    justify-content: space-around;
  
    .container {
      .pre,
      .next {
        width: 25px;
        height: 25px;
        text-align: center;
        margin: 0 10px;
      }
      span {
        width: 20px;
        height: 20px;
        padding: 0 10px;
        cursor: pointer;
      }
      .disabled {
        pointer-events: none;
        opacity: 0.4;
        background-color: #444;
      }
    }
    .pagesize {
      height: 20px;
      margin: 5px 0;
    }
    .goPage {
      input {
        width: 30px;
        margin: 0 5px;
        outline: none;
      }
    }
    .active {
      color: skyblue;
    }
  }
  </style>
  ```
  
* 使用

  * ```vue
                <!-- 分页器 -->
                <Pagination
                  :total="total"
                  :currentpage="page.page"
                  :pagesize="page.pagesize"
                  @changepages="changepages"
                ></Pagination>
    ```



#### 组件的全局注册

* components/index.js

  * ```js
    // 全局自定义组件的注册
    import PageTool from "./PageTool";
    
    export default {
      // vue.use()的时候会调用里面的install(v)方法,而install方法的参数v就是vue实例
      install(Vue) {
        Vue.component("PageTool", PageTool);
      },
    };
    
    ```

* main.js

  * ```js
    // 引入全局自定义组件
    import Component from "@/components";
    Vue.use(Component);
    ```

  * 

